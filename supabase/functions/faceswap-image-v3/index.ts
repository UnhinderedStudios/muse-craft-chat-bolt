import { corsHeaders } from '../_shared/cors.ts';
import { encodeBase64 } from "https://deno.land/std@0.224.0/encoding/base64.ts";

console.log('Starting faceswap-image-v3 function');

// Simple direct prompt construction for Gemini
function buildPrompt(userInput: string, backgroundHex?: string, characterCount?: number): string {
  const baseInstructions = "Match the overall framing, camera angle, and lighting style. Keep background identical but totally replace the character in the reference image, no reference to it should exist in the final image unless instructed in.";
  const characterInstruction = ` ${characterCount || 1} character${(characterCount || 1) > 1 ? 's' : ''}. All characters must match the gender specified, if 1 gender is specified then all characters must be that gender unless properly defined.`;
  const objectRestrictions = " NO objects, props, instruments, tools. Empty hands. Clean background.";
  const backgroundInstruction = backgroundHex ? ` Background color: Overall background colour should be (do not actually enter hex code text into the final result only the color of it): ${backgroundHex}.` : '';
  
  return `${userInput}. ${baseInstructions}${backgroundInstruction}${characterInstruction}${objectRestrictions}`;
}

// Generate image using Gemini Flash 2.5
async function generateBaseImageWithGemini(prompt: string, backgroundHex?: string, characterCount?: number, requestId?: string): Promise<string> {
  const geminiKey = Deno.env.get('GEMINI_API_KEY');
  if (!geminiKey) {
    throw new Error('GEMINI_API_KEY not found in environment');
  }

  const fullPrompt = buildPrompt(prompt, backgroundHex, characterCount);
  console.log(`üé® [${requestId}] Generating base image with Gemini: "${fullPrompt}"`);

  const requestBody = {
    contents: [{
      role: "user",
      parts: [{
        text: fullPrompt
      }]
    }],
    generationConfig: {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 8192,
    },
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
    ]
  };

  const geminiResponse = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${geminiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    }
  );

  if (!geminiResponse.ok) {
    const errorText = await geminiResponse.text();
    console.error(`‚ùå [${requestId}] Gemini API error:`, errorText);
    throw new Error(`Gemini API request failed: ${geminiResponse.status}`);
  }

  const geminiData = await geminiResponse.json();
  console.log(`‚úÖ [${requestId}] Gemini response received`);
  console.log(`üîç [${requestId}] Full Gemini response:`, JSON.stringify(geminiData, null, 2));

  // Extract base64 image from Gemini response
  if (geminiData.candidates?.[0]?.content?.parts) {
    const parts = geminiData.candidates[0].content.parts;
    console.log(`üîç [${requestId}] Parts:`, JSON.stringify(parts, null, 2));
    
    for (const part of parts) {
      // Check both inline_data and inlineData properties
      const inline = part.inline_data || part.inlineData;
      if (inline?.data) {
        console.log(`üñºÔ∏è [${requestId}] Base image generated successfully`);
        return inline.data;
      }
    }
  }

  console.error(`‚ùå [${requestId}] No image data found in response:`, JSON.stringify(geminiData, null, 2));
  throw new Error('No image generated by Gemini');
}

Deno.serve(async (req: Request) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('Processing faceswap request...');
    
    // Get environment variables
    const magicApiKey = Deno.env.get('MAGICAPI_KEY');
    if (!magicApiKey) {
      throw new Error('MAGICAPI_KEY not found in environment');
    }

    // Parse the FormData from the request
    const formData = await req.formData();
    
    const prompt = formData.get('prompt') as string;
    const backgroundHex = formData.get('backgroundHex') as string;
    const characterCount = formData.get('characterCount') as string;
    const facialReference = formData.get('facialReference') as File; // This is the source image (face to swap)
    const requestId = `faceswap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    console.log(`üìã [${requestId}] Request parameters:`, {
      prompt,
      backgroundHex,
      characterCount,
      hasFacialReference: !!facialReference,
      facialReferenceType: facialReference?.type
    });

    if (!prompt) {
      throw new Error('No prompt provided for image generation');
    }

    if (!facialReference) {
      throw new Error('No facial reference provided for face swap');
    }

    // Stage 1: Generate base image with Gemini
    console.log(`üé® [${requestId}] Stage 1: Generating base image with Gemini...`);
    const baseImageData = await generateBaseImageWithGemini(
      prompt, 
      backgroundHex, 
      parseInt(characterCount) || 1,
      requestId
    );

    // Convert base64 to blob for MagicAPI
    const baseImageBuffer = new Uint8Array(
      atob(baseImageData)
        .split('')
        .map(char => char.charCodeAt(0))
    );
    const baseImageBlob = new Blob([baseImageBuffer], { type: 'image/jpeg' });
    
    console.log(`‚úÖ [${requestId}] Stage 1 completed: Base image generated (${baseImageBlob.size} bytes)`);

    // Stage 2: Face swap with MagicAPI
    console.log(`üîÑ [${requestId}] Stage 2: Applying face swap with MagicAPI...`);

    // Prepare FormData for MagicAPI Face Swap v3
    const magicApiFormData = new FormData();
    
    // source_image: The face to extract (facial reference image)
    magicApiFormData.append('source_image', facialReference);
    
    // target_image: The generated base image from Gemini
    magicApiFormData.append('target_image', baseImageBlob);

    console.log(`üåê [${requestId}] Sending request to MagicAPI Face Swap v3...`);
    
    // Convert baseImageBlob to File with proper filename
    const targetFile = new File([baseImageBlob], 'target.jpg', { type: 'image/jpeg' });
    magicApiFormData.set('target_image', targetFile);
    
    // Call MagicAPI Face Swap v3 with correct API endpoint
    const magicApiResponse = await fetch('https://prod.api.market/api/v1/magicapi/faceswap-capix', {
      method: 'POST',
      headers: {
        'X-API-Key': magicApiKey,
        'X-RapidAPI-Key': magicApiKey,
        'Accept': 'image/*,application/json'
      },
      body: magicApiFormData
    });

    if (!magicApiResponse.ok) {
      const responseHeaders = Object.fromEntries(magicApiResponse.headers.entries());
      const responseText = await magicApiResponse.text();
      const bodySnippet = responseText.substring(0, 500);
      
      console.error(`‚ùå [${requestId}] MagicAPI error:`, { 
        status: magicApiResponse.status, 
        statusText: magicApiResponse.statusText,
        headers: responseHeaders,
        bodySnippet: bodySnippet
      });
      
      // Try to parse JSON error if response is JSON
      let errorMessage = `MagicAPI request failed: ${magicApiResponse.status} ${magicApiResponse.statusText}`;
      try {
        const errorJson = JSON.parse(responseText);
        if (errorJson.message || errorJson.error) {
          errorMessage += ` - ${errorJson.message || errorJson.error}`;
        }
      } catch {
        // Not JSON, use status text
      }
      
      throw new Error(errorMessage);
    }

    // Get the response - MagicAPI returns the processed image directly
    const resultBlob = await magicApiResponse.blob();
    
    console.log(`‚úÖ [${requestId}] MagicAPI response received:`, {
      type: resultBlob.type,
      size: resultBlob.size
    });

    // Convert blob to base64 for consistent response format
    const arrayBuffer = await resultBlob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    const base64String = btoa(String.fromCharCode(...uint8Array));
    const base64Image = `data:${resultBlob.type || 'image/jpeg'};base64,${base64String}`;

    const response = {
      images: [base64Image],
      enhancedPrompt: `Two-stage generation: "${prompt}" ‚Üí Face swap applied`,
      debug: {
        source: 'Gemini ‚Üí MagicAPI Face Swap v3',
        originalPrompt: prompt,
        backgroundHex,
        characterCount,
        facialReferenceType: facialReference.type,
        baseImageSize: baseImageBlob.size,
        resultType: resultBlob.type,
        resultSize: resultBlob.size,
        pipeline: 'Gemini Generation ‚Üí MagicAPI Face Swap'
      }
    };

    console.log(`üéâ [${requestId}] Two-stage face swap completed successfully`);

    return new Response(JSON.stringify(response), {
      headers: { 
        ...corsHeaders, 
        'Content-Type': 'application/json' 
      }
    });

  } catch (error) {
    console.error('Two-stage face swap error:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Two-stage face swap failed';
    
    return new Response(
      JSON.stringify({
        error: errorMessage,
        images: [],
        debug: {
          pipeline: 'Gemini Generation ‚Üí MagicAPI Face Swap',
          stage: (error instanceof Error && error.message?.includes('Gemini')) ? 'Stage 1: Image Generation' : 'Stage 2: Face Swap',
          error: errorMessage
        }
      }),
      {
        status: 500,
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        }
      }
    );
  }
});