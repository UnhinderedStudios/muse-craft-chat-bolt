import { corsHeaders } from '../_shared/cors.ts';
import { encodeBase64 } from "https://deno.land/std@0.224.0/encoding/base64.ts";

console.log('Starting faceswap-image-v3 function');

// Simple direct prompt construction for Gemini
function buildPrompt(userInput: string, backgroundHex?: string, characterCount?: number): string {
  const baseInstructions = "Match the overall framing, camera angle, and lighting style. Keep background identical but totally replace the character in the reference image, no reference to it should exist in the final image unless instructed in.";
  const characterInstruction = ` ${characterCount || 1} character${(characterCount || 1) > 1 ? 's' : ''}. All characters must match the gender specified, if 1 gender is specified then all characters must be that gender unless properly defined.`;
  const objectRestrictions = " NO objects, props, instruments, tools. Empty hands. Clean background.";
  const backgroundInstruction = backgroundHex ? ` Background color: Overall background colour should be (do not actually enter hex code text into the final result only the color of it): ${backgroundHex}.` : '';
  
  return `${userInput}. ${baseInstructions}${backgroundInstruction}${characterInstruction}${objectRestrictions}`;
}

// Generate image using Gemini Flash 2.5
async function generateBaseImageWithGemini(prompt: string, backgroundHex?: string, characterCount?: number, requestId?: string): Promise<string> {
  const geminiKey = Deno.env.get('GEMINI_API_KEY');
  if (!geminiKey) {
    throw new Error('GEMINI_API_KEY not found in environment');
  }

  const fullPrompt = buildPrompt(prompt, backgroundHex, characterCount);
  console.log(`üé® [${requestId}] Generating base image with Gemini: "${fullPrompt}"`);

  const requestBody = {
    contents: [{
      role: "user",
      parts: [{
        text: fullPrompt
      }]
    }],
    generationConfig: {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 8192,
    },
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
    ]
  };

  const geminiResponse = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${geminiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    }
  );

  if (!geminiResponse.ok) {
    const errorText = await geminiResponse.text();
    console.error(`‚ùå [${requestId}] Gemini API error:`, errorText);
    throw new Error(`Gemini API request failed: ${geminiResponse.status}`);
  }

  const geminiData = await geminiResponse.json();
  console.log(`‚úÖ [${requestId}] Gemini response received`);
  console.log(`üîç [${requestId}] Full Gemini response:`, JSON.stringify(geminiData, null, 2));

  // Extract base64 image from Gemini response
  if (geminiData.candidates?.[0]?.content?.parts) {
    const parts = geminiData.candidates[0].content.parts;
    console.log(`üîç [${requestId}] Parts:`, JSON.stringify(parts, null, 2));
    
    for (const part of parts) {
      // Check both inline_data and inlineData properties
      const inline = part.inline_data || part.inlineData;
      if (inline?.data) {
        console.log(`üñºÔ∏è [${requestId}] Base image generated successfully`);
        return inline.data;
      }
    }
  }

  console.error(`‚ùå [${requestId}] No image data found in response:`, JSON.stringify(geminiData, null, 2));
  throw new Error('No image generated by Gemini');
}

Deno.serve(async (req: Request) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('Processing faceswap request...');
    
    // Get environment variables
    const magicApiKey = Deno.env.get('MAGICAPI_KEY');
    if (!magicApiKey) {
      throw new Error('MAGICAPI_KEY not found in environment');
    }

    // Parse the FormData from the request
    const formData = await req.formData();
    
    const prompt = formData.get('prompt') as string;
    const backgroundHex = formData.get('backgroundHex') as string;
    const characterCount = formData.get('characterCount') as string;
    const facialReference = formData.get('facialReference') as File; // This is the source image (face to swap)
    const requestId = `faceswap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    console.log(`üìã [${requestId}] Request parameters:`, {
      prompt,
      backgroundHex,
      characterCount,
      hasFacialReference: !!facialReference,
      facialReferenceType: facialReference?.type
    });

    if (!prompt) {
      throw new Error('No prompt provided for image generation');
    }

    if (!facialReference) {
      throw new Error('No facial reference provided for face swap');
    }

    // Stage 1: Generate base image with Gemini
    console.log(`üé® [${requestId}] Stage 1: Generating base image with Gemini...`);
    const baseImageData = await generateBaseImageWithGemini(
      prompt, 
      backgroundHex, 
      parseInt(characterCount) || 1,
      requestId
    );

    // Convert base64 to blob for MagicAPI using more efficient approach
    const base64DataUrl = `data:image/png;base64,${baseImageData}`;
    const baseImageResponse = await fetch(base64DataUrl);
    const baseImageBlob = await baseImageResponse.blob();
    
    console.log(`‚úÖ [${requestId}] Stage 1 completed: Base image generated (${baseImageBlob.size} bytes)`);

    // Stage 2: Face swap with MagicAPI using correct endpoint structure
    console.log(`üîÑ [${requestId}] Stage 2: Applying face swap with MagicAPI...`);

    // Convert images to base64 URLs for the API
    const facialReferenceBuffer = new Uint8Array(await facialReference.arrayBuffer());
    const facialReferenceBase64 = encodeBase64(facialReferenceBuffer);
    const facialReferenceDataUrl = `data:${facialReference.type || 'image/jpeg'};base64,${facialReferenceBase64}`;

    const baseImageDataUrl = `data:image/png;base64,${baseImageData}`;

    // Prepare JSON payload for MagicAPI
    const apiPayload = {
      input: {
        swap_image: facialReferenceDataUrl,    // Face to swap from
        target_image: baseImageDataUrl,        // Target image to swap to
        enhance_image: true
      }
    };

    console.log(`üåê [${requestId}] Making request to MagicAPI /run endpoint...`);
    
    // Call MagicAPI /run endpoint to start async processing
    const magicApiResponse = await fetch('https://prod.api.market/api/v1/magicapi/faceswap-image-v3/run', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-market-key': magicApiKey,
      },
      body: JSON.stringify(apiPayload)
    });

    if (!magicApiResponse.ok) {
      const responseHeaders = Object.fromEntries(magicApiResponse.headers.entries());
      const responseText = await magicApiResponse.text();
      
      console.error(`‚ùå [${requestId}] MagicAPI /run error:`, { 
        status: magicApiResponse.status, 
        statusText: magicApiResponse.statusText,
        headers: responseHeaders,
        body: responseText
      });
      
      throw new Error(`Failed to start MagicAPI prediction: ${magicApiResponse.status} ${magicApiResponse.statusText}`);
    }

    const predictionData = await magicApiResponse.json();
    const predictionId = predictionData.id;
    
    if (!predictionId) {
      console.error(`‚ùå [${requestId}] No prediction ID in response:`, predictionData);
      throw new Error('No prediction ID returned from MagicAPI');
    }

    console.log(`üìã [${requestId}] Prediction created with ID: ${predictionId}`);
    console.log(`üîÑ [${requestId}] Starting polling for prediction status...`);

    // Poll for prediction completion using /status endpoint
    const maxAttempts = 120; // 10 minutes max (5 second intervals)
    const pollInterval = 5000; // 5 seconds
    let attempts = 0;
    let resultImageUrl: string | null = null;

    while (attempts < maxAttempts) {
      attempts++;
      
      console.log(`üîç [${requestId}] Checking prediction status... (attempt ${attempts}/${maxAttempts})`);
      
      const statusResponse = await fetch(`https://prod.api.market/api/v1/magicapi/faceswap-image-v3/status/${predictionId}`, {
        headers: {
          'accept': 'application/json',
          'x-api-market-key': magicApiKey,
        }
      });

      if (!statusResponse.ok) {
        console.error(`‚ùå [${requestId}] Status check failed:`, statusResponse.status, statusResponse.statusText);
        throw new Error(`Failed to check prediction status: ${statusResponse.status}`);
      }

      const statusData = await statusResponse.json();
      console.log(`üìä [${requestId}] Prediction status: ${statusData.status}`);

      if (statusData.status === 'COMPLETED') {
        // Get the final result image URL
        if (statusData.output?.image_url) {
          resultImageUrl = statusData.output.image_url;
          console.log(`‚úÖ [${requestId}] Prediction completed successfully`);
          break;
        } else {
          throw new Error('No image URL in completed prediction');
        }
      } else if (statusData.status === 'FAILED') {
        console.error(`‚ùå [${requestId}] Prediction failed:`, statusData.error || 'Unknown error');
        throw new Error(`Prediction failed: ${statusData.error || 'Unknown error'}`);
      }

      // Wait before next poll (IN_QUEUE, PROCESSING, etc.)
      if (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }
    }

    if (attempts >= maxAttempts) {
      throw new Error('Prediction timed out after 10 minutes');
    }

    if (!resultImageUrl) {
      throw new Error('No result image URL obtained from prediction');
    }

    // Fetch the final result image
    console.log(`üì• [${requestId}] Downloading result image from: ${resultImageUrl}`);
    const imageResponse = await fetch(resultImageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch result image: ${imageResponse.status}`);
    }
    const resultBlob = await imageResponse.blob();
    
    console.log(`‚úÖ [${requestId}] MagicAPI response received:`, {
      type: resultBlob.type,
      size: resultBlob.size
    });

    // Convert blob to base64 for consistent response format
    const arrayBuffer = await resultBlob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    const base64String = encodeBase64(uint8Array);
    const base64Image = `data:${resultBlob.type || 'image/jpeg'};base64,${base64String}`;

    const response = {
      images: [base64Image],
      enhancedPrompt: `Two-stage generation: "${prompt}" ‚Üí Face swap applied`,
      debug: {
        source: 'Gemini ‚Üí MagicAPI Face Swap v3',
        originalPrompt: prompt,
        backgroundHex,
        characterCount,
        facialReferenceType: facialReference.type,
        baseImageSize: baseImageBlob.size,
        resultType: resultBlob.type,
        resultSize: resultBlob.size,
        pipeline: 'Gemini Generation ‚Üí MagicAPI Face Swap'
      }
    };

    console.log(`üéâ [${requestId}] Two-stage face swap completed successfully`);

    return new Response(JSON.stringify(response), {
      headers: { 
        ...corsHeaders, 
        'Content-Type': 'application/json' 
      }
    });

  } catch (error) {
    console.error('Two-stage face swap error:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Two-stage face swap failed';
    
    return new Response(
      JSON.stringify({
        error: errorMessage,
        images: [],
        debug: {
          pipeline: 'Gemini Generation ‚Üí MagicAPI Face Swap',
          stage: (error instanceof Error && error.message?.includes('Gemini')) ? 'Stage 1: Image Generation' : 'Stage 2: Face Swap',
          error: errorMessage
        }
      }),
      {
        status: 500,
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        }
      }
    );
  }
});